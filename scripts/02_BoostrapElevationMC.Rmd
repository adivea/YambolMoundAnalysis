---
title: "Bootstrap Analysis of Mound Elevations"
author: "Adela Sobotkova"
date: "updated`r Sys.Date()`"
output:
  rmdformats::readthedown:
    highlight: kate
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(rmdformats)

## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
	             cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```

# Bootstrapping Mound Elevations in Yambol Region 
This script is inspired by Kyle Bocinsky's comparison of cell tower elevations with background terrain in this chapter https://benmarwick.github.io/How-To-Do-Archaeological-Science-Using-R/landscape-based-hypothesis-testing-in-r.html
. I have adapted the script to burial mounds in Yambol and adjusted the wrangling of the monte carlo results to compensate for older libraries.
 
 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Clip elevation raster by Yambol region boundary
```{r}
Y_elev <- crop(elev, Y_region)
Y_elev <- mask(Y_elev, Y_region)
plot(Y_elev)

```

## Random sample of elevations
```{r}
random <- sampleRandom(Y_elev, 1000)

hist(Yam_mnds$elevAster, breaks = 25,  main = "Histogram of random Yambol region (grey) \n and mound location (pink) elevations")
hist(random, col = "pink", breaks = 25, add = T, alpha = 0.5)
```
There seems to be a considerable overlap, but we only compared the mound elevations to one sample of regional elevations. So let's try with a larger sample size.

## Calculate kernel density curves for sites and landscape
We can calculate kernel density curves using the density() function available in all R installations. This code block gets a little complicated. The first section is straightforward: we estimate the probability density for all elevations between 150 and 1250 masl (the domain of the county elevation). The second section is a bit more complicated: we estimate probability densities for 99 random samples from the elevation data. (You would probably want to draw more resamples than this in a real analysis). Each sample is of the same number of sites as there are mounds. This is called Monte Carlo resampling. The code section performs the sampling, then calculates a 95% confidence interval for the sampled data using quantiles. We will use the foreach package (and its %do% function) to repeat and output the resampling.


```{r monte-carlo-gambling}

# Calculate the mound densities

library(foreach)
library(purrrlyr)


mounds_densities <- Yam_mnds %$%
  elevAster %>%
  density(from = 50,
            to = 1250,
            n = 1201) %>% 
   broom::tidy() %>%
   tibble::as_tibble() %>%
  dplyr::mutate(y = y * 1201) %>%
  dplyr::rename(Elevation = x,
                Frequency = y)


# Calculate possible densities across the study area using resampling
# -------------------------
# Load the NED elevations into memory for fast resampling
yambol_region_values <- Y_elev %>%
  values() %>%
  na.omit() # Drop all masked (NA) locations

# Draw 99 random samples, and calculate their densities

yambol_region_densities <- foreach::foreach(n = 1:99, .combine = rbind) %do% {
  yambol_region_values %>%
    sample(nrow(Yam_mounds),
           replace = FALSE) %>%
    density(from = 50,
            to = 1250,
            n = 1201) %>% 
    broom::tidy() %>%
    tibble::as_tibble() %>%
    dplyr::mutate(y = y * 1201)
} %>%
  dplyr::group_by(x)

# Check the interim dataset
head(yambol_region_densities)

# Calculate quantiles
yambol_densities <- yambol_region_densities %>%
  purrrlyr::by_slice(function(x){
    quantile(x$y, probs = c(0.025, 0.5, 0.975)) %>%
      t() #%>%
      #broom::tidy()  
    }, .collate = "rows") #%>%
  #magrittr::set_names(c("Elevation", "Lower CI", "Frequency", "Upper CI"))

# Rename and widen the quantiles dataset
yambol_densities$names <- rep(c("Lower CI", "Median", "Upper CI"), 1201)
yambol_densities_wide <- yambol_densities %>% pivot_wider(names_from = names,
                     values_from = .out,
                     values_fill = list(.out = NA))
names(yambol_densities_wide)[1] <- "Elevation"
head(yambol_densities_wide)

# Rename original densities
yambol_region_densities <- yambol_region_densities %>% 
  dplyr::rename(Elevation = x,
                Frequency = y)

```

## Plot the kernel density curves
Weâ€™ll perform a statistical test on the mounds and resampled elevation data in a minute, but first it is just as helpful to view a graph of the two data sets. Like all things, R has many different ways of graphing data, but the ggplot2 package from Hadley Wickam is fast becoming the framework-du jour for graphics in R. The plotly package can be used to effortlessly convert ggplot2 graphs into interactive HTML graphics. ggplot2 uses a pipe-like system for building graphs, where graphical elements are appended to one-another using the + operator. Hover over the plot to explore it interactively.


## Plot both distributions using ggplot2
```{r plot-densities}
g <- ggplot() +
  geom_line(data = yambol_region_densities,
            mapping = aes(x = Elevation,
                          y = Frequency)) +
  geom_ribbon(data = yambol_densities_wide,
              mapping = aes(x = Elevation,
                            ymin = `Lower CI`,
                            ymax = `Upper CI`),
              col = "lightgrey",
              alpha = 0.5) +
  geom_line(data = mounds_densities,
               mapping = aes(x = Elevation,
                             y = Frequency),
               color = "red")
g
```
This plot is not much more revealing than the histogram we started with.  The landscape data (represented by the black band enclosed by gray confidence interval) is right skewed and has a single main mode at c. 150 masl. The mound data has a much more tight and higher mode at c. 160 masl, and is also right skewed. From this visual investigation alone, we can not see whether the mound locations differ from a random sample taken from the Yambol region landscape as a whole.


##..then create an interactive html widget using plotly.
```{r ggplotly, eval=false}
install.packages("ggplotly")
install.packages("R")
library(ggplotly)

ggplotly(g)# Create the HTML widget
```

