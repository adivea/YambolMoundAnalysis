---
title: "Visibility"
author: "Adela Sobotkova"
date: "2022-12-14"
output: html_document
---
## Purpose and prerequisites
This script calculates mutual intervisibility (line of sight) between various archaeological features, starting here with burial mounds in the Yambol Region within ASTER elevation raster (30m spatial resolution). 

This markdown guides you to: 

1. Define functions to calculate line-of-sight visibility between two features and automate the process for a 1000 features. 
2. Visualize intervisibility for calculated features (here: mounds in Yambol). To visualize, you can skip directly to section "Visualizing Intervisibility".

The script basically works, calculating linestrings, raster profiles, and intervisibility between Yam_mounds and generating maps

The proof of concept is done on BA mounds and to replicate it you might need: 
- to run 09 BA mounds to have the necessary libraries and digital objects

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE)
library(sf)
library(raster)
library(tidyverse)
library(mapview)
```

## Load 2009-2022 data
```{r load-mounds}

Y_elev <- raster("../output_data/large/Yelev32635.tif")
# Yambol mounds
Yam_mnds <- readRDS("../output_data/Yam_dd_mnds.rds") # 1073 features
mapview(Yam_mnds, zcol = "Type")

Yam_mnds %>% 
  group_by(Type) %>% 
  tally()
```

 
## Intervisibility functions

Intervisibility in human terms mean that two or more points in the landscape have a clear line of sight between them (given reasonable visibility). In computational terms, it means that a straight line connecting the z values of the A and B (the two end-points) does not intersect a polygon formed by terrain profile between them. If it doesn't, A can see B.
Let's test such line of sight by extracting data out of raster cells between our BA points.

https://stackoverflow.com/questions/21841387/r-code-that-evaluates-line-of-sight-los-between-two-lat-lon-points 

https://gis.stackexchange.com/questions/272122/performing-viewshed-analysis-in-r
```{r define-cansee-functions}
cansee <- function(r, xy1, xy2, h1=0, h2=0){
### can xy1 see xy2 on DEM r?
### Y_elev is a DEM in same x,y, z units
### xy1 and xy2 are 2-length vectors of x,y coords
### h1 and h2 are extra height offsets (ie. mound heights)
###  (eg top of mast, observer on a ladder etc)
    xyz = rasterprofile(r, xy1, xy2)
    np = nrow(xyz)-1
    h1 = xyz$z[1] + h1
    h2 = xyz$z[np] + h2
    hpath = h1 + (0:np)*(h2-h1)/np
    return(!any(hpath < xyz$z))
}

viewTo <- function(r, xy, xy2, h1=0, h2=0, progress="none"){
    ## xy2 is a matrix of x,y coords (not a data frame)
    require(dplyr)
    apply(xy2, 1, function(d){cansee(r,xy,d,h1,h2)}, .progress=progress)
}

viewTo <- function(r, xy, xy2, h1=0, h2=0){
    ## xy2 is a matrix of x,y coords (not a data frame)
    require(dplyr)
    apply(xy2, 1, function(d){cansee(r,xy,d,h1,h2)})
}

rasterprofile <- function(r, xy1, xy2){
### sample a raster along a straight line between two points
### try to match the sampling size to the raster resolution
    dx = sqrt( (xy1[1]-xy2[1])^2 + (xy1[2]-xy2[2])^2 )
    nsteps = 1 + round(dx/ min(res(r)))
    xc = xy1[1] + (0:nsteps) * (xy2[1]-xy1[1])/nsteps
    yc = xy1[2] + (0:nsteps) * (xy2[2]-xy1[2])/nsteps
    data.frame(x=xc, y=yc, z=r[cellFromXY(r,cbind(xc,yc))])
}
```
Let's test these three functions with real data 

```{r mound-check}
Yam_mnds[1:3,]
```

## Automating the visibility calculation

### prep the data for cansee() function
```{r auto-prep}
# origin point coordinates and height
Yam_mnds %>% 
  group_by(Type) %>% tally()

Yam_mnds$HeightMax[is.na(Yam_mnds$HeightMax)] <- 0


origin <- cbind(st_coordinates(Yam_mnds), h = Yam_mnds$HeightMax)
target <- origin 

class(origin)
```

### slow automation via a for-loop
Loops take long so evaluation is off.
```{r loop, eval = FALSE}
# LOOP: works but takes days to finish, reduce the i and e if running a test!
result_table <- NULL
for (i in 1:nrow(origin)){
  for (e in 1:nrow(target)){print(e)
      result = cansee(Y_elev, origin[i,1:2], target[e,1:2], h1 = origin[i,3], h2 = target[e,3])
    result_row <- cbind(i,e, result) 
    result_table <- rbind(result_table, result_row)
  }

}

# I stopped the process after 24 hours when it reached ~250,000 calculations
# maxima were i = 241, and e = 780 ; restart the calculations there

head(result_table)
tail(result_table)
saveRDS(result_table, "../output_data/Yam_mnd_intervis250k.rds")

```

Finishing the 1,000,000 calculations takes a while! (1 hr so far at 17.18 on Thursday night).
OK, some 24 hours later (Friday afternoon), 241 mounds (*1000) were completed. Clearly the tasks takes 4 days unless we successfully ...

### Parallelize!
Parallelisation is much faster than loops but still takes ca 6-12 hours for the whole dataset so run it on demand, if needed
```{r auto-foreach, eval = FALSE}
# install.packages("doParallel")
# install.packages("foreach")
library(foreach)
library(doParallel)
library(data.table)

detectCores() # 22 as some are multi-threaded
detectCores(logical = FALSE) # 16 real ones

cl <- makeCluster(12) # keep 4 cores so screensaver can run on W11
registerDoParallel(cl)

# Start experiment
origin <- cbind(st_coordinates(Yam_mnds), h = Yam_mnds$HeightMax)
target <- origin 

# nesting both i and e with foreach 
ie_table <- foreach (i= 1:nrow(origin), .combine = 'rbind',.packages = c("data.table", "raster")) %do% {
  print(i)
  foreach( e= 1:nrow(target), .combine = 'rbind',.packages = c("data.table", "raster")) %dopar% {
  print(e)
  result = cansee(Y_elev, origin[i,1:2], target[e,1:2], h1 = origin[i,3], h2 = target[e,3])
  result_row <- c(i,e, result)
  }
 # result_table <- rbind(result_table, result_row)
}

dim(ie_table) # 1,151,329 calculations take ~12 hours (10x less than for loop) 
saveRDS(ie_table, "../output_data/Yam_mnds_intervis.rds")
```
### Compare efficiency between for-loop and foreach
Let's run 4 * 4 (16) or/and 14*14 (~196) calculations using both a for loop and foreach to compare their relative speeds.

```{r compare-loop-foreach, eval = FALSE}
loop_table <- NULL
runtime1 <- system.time(
for (i in 1060:nrow(origin)){
  print(i)
  for (e in 1060:nrow(target)) {
    print(e)
    result = cansee(Y_elev, origin[i,1:2], target[e,1:2], h1 = origin[i,3], h2 = target[e,3])
    result_row <- cbind(i,e, result)
   loop_table <- rbind(loop_table, result_row)
    }
}
)

runtime2 <- system.time(
parallel_table <- foreach (i= 1060:nrow(origin), .combine = 'rbind',.packages = c("data.table", "raster")) %do% {
  print(i)
  foreach( e= 1060:nrow(target), .combine = 'rbind',.packages = c("data.table", "raster")) %dopar% {
  print(e)
  result = cansee(Y_elev, origin[i,1:2], target[e,1:2], h1 = origin[i,3], h2 = target[e,3])
  result_row <- c(i,e, result)
  }
}
)

dim(parallel_table)
dim(loop_table)
runtime1
runtime2
```

At 16 iterations (16 results), the foreach 'elapsed' time is half of the loop and 'user' time is 5x less.
> runtime1
   user  system elapsed 
   0.06    0.01    0.23 
> runtime2
   user  system elapsed 
   0.01    0.00    0.13 
   
At 196 iterations (196 results), the foreach (with 12 cores) 'elapsed' time is 1/3 of the for loop and 'user' time is 50x less    
> runtime1
   user  system elapsed 
   0.53    0.02    3.14 
> runtime2
   user  system elapsed 
   0.01    0.00    1.06
   
### Explore intervisibility results   
```{r results-test}
# Check the results of the initial intervisibility run
result_table <- readRDS("../output_data/result_table.rds")
result_table <- as.tibble(result_table)

head(result_table)
result_table <- result_table %>% 
  rename(i = V1, e = V2, visibility = V3)

# 10 most commanding mounds! i is the index, n is the number of visible features from it
result_table %>% 
  group_by(i) %>% 
  tally(visibility) %>% 
  arrange(desc(n)) # mounds no 333, 38 and 1 see the most other mounds (393-409)

# all the mounds visible from mound no. 333 (n = 409)
result_table %>% 
  filter(i == 333, visibility == 1) %>% 
  arrange(desc(e)) %>% 
  distinct(e) 
```



### Link results to actual mound locations

```{r link-TRAP-to-results}
result_table$TRAPorigin <- Yam_mnds$TRAP[result_table$i]
result_table$TRAPtarget <- Yam_mnds$TRAP[result_table$e]


# all the mounds visible from mound no. 333 (n = 409)
result_table %>% 
  filter(i == 333, visibility == 1) %>% 
  arrange(desc(e)) %>% 
  distinct(TRAPtarget) %>% 
  pull() -> visiblefrom9412  # list of TRAP numbers visible from 9412

```


```{r most-intervisible-map}

library(mapview)

result_table %>% 
  group_by(TRAPorigin) %>% 
  tally(visibility) %>% 
  arrange(desc(n)) %>% 
  slice(1:25) %>% 
  #rename(TRAP = TRAPorigin) %>% 
  #merge(Yam_mnds, by = c("TRAP")) #%>% 
  left_join(Yam_mnds, by = c("TRAPorigin"="TRAP")) %>%
  st_as_sf(crs = 32635) %>% 
  mapview(cex = "n" , zcol = "HeightMax") +mapview(Yam_mnds,cex = 0.1) +
  mapview(Yam_mnds %>% dplyr::filter(TRAP%in%visiblefrom9412), cex = 1)

```
```{r}
# Save the intervisibility table linked with TRAP ids
saveRDS(result_table, "../output_data/Yam_mnds_intervis.rds")
# i and e are the same as TRAPorigin and TRAPtarget
```



## Visualizing intervisibility

```{r most-intervisible-map}
# load data
mnd_vis <- readRDS("../output_data/Yam_mnds_intervis.rds")

# group by viewpoint, join to spatial points and plot on a map
library(mapview)

mnd_vis %>% 
  group_by(TRAPorigin) %>% 
  tally(visibility) %>% 
  arrange(desc(n)) %>% 
  slice(1:25) %>% 
  # join the summarized dataframe of 25 most visible mounds to mound spatial points
  left_join(Yam_mnds, by = c("TRAPorigin"="TRAP")) %>%
  # activate the geometry column with proper CRS
  st_as_sf(crs = 32635) %>% 
  # plot the 25 most visible mounds, varying their radius by number of visible features from this location and varying color by mound height
  mapview(cex = "n" , zcol = "HeightMax") + 
  # show other mounds in the background as small dots
  mapview(Yam_mnds,cex = 0.1) +
  # differentiate mounds visible from 9412 (the most visible single features)
  mapview(Yam_mnds %>% dplyr::filter(TRAP%in%visiblefrom9412), cex = 1)

mapview(Yam_mnds[Yam_mnds$TRAP %in% visiblefrom9412,])
```

### Visibility lines for 9412


```{r linestrings-9412}
# Test linestring creation from 9412 and its 409 visible mounds. The coords object needs to be a matrix, but to cbind one to many coordinates the component columns need to be dataframes.

coords <- as.matrix(cbind(as.data.frame(st_coordinates(Yam_mnds %>% filter(TRAP == 9412))),
                as.data.frame(st_coordinates(Yam_mnds %>% filter(TRAP %in% visiblefrom9412)))))

lines_sm <-  st_sfc(
     lapply(1:nrow(coords),
           function(i){
             st_linestring(matrix(coords[i,],ncol=2,byrow=TRUE))
           }))

st_crs(lines_sm) <- st_crs(Yam_mnds)


library(mapview)
mapview(lines_sm)+mapview(Yam_mnds %>% filter(TRAP %in% visiblefrom9412))

# https://stackoverflow.com/questions/65498300/how-to-efficiently-create-linestrings-from-points
# https://stackoverflow.com/questions/58150279/plotting-lines-between-two-sf-point-features-in-r

```

The linestrings for 9412 seem to reach the national border, which is hard to believe... 
What is going on here? Let's check the prominence of the points first and raster profiles second.

## Raster profile
```{r}
profile <- function(IDorigin, IDtarget){
     # must be an elevation raster
  # library(raster)
  # if(!exists(Y_elev)){
  #    Y_elev <- raster("../output_data/large/Yelev32635.tif")}
     # must be a simple feature with same CRS as raster
  library(sf) 
  # target just as a dataframe of x, y, WITHOUT height
  origin <- Yam_mnds %>%  
         filter(TRAP == IDorigin) %>% 
          st_coordinates()  
  target <- Yam_mnds %>% 
         filter(TRAP == IDtarget) %>%
          st_coordinates()
  # target needs to be a dataframe of x, y, and height
  # origin <- data.frame(Yam_mnds %>%  
  #        filter(TRAP == origin) %>% 
  #         st_coordinates(), h= Yam_mnds$HeightMax[Yam_mnds$TRAP == origin])
  #   target <- data.frame(Yam_mnds %>% 
  #        filter(TRAP == target) %>% 
  #         st_coordinates(), h= Yam_mnds$HeightMax[Yam_mnds$TRAP == target])
  testprofile <- rasterprofile(Y_elev,  origin, target)
  x = c(0,nrow(testprofile))
  y = testprofile$z[c(1,nrow(testprofile))]

    # Plot profile with start and end point elevation
  plot(testprofile$z, type = "l", 
       main = paste0("Terrain profile between mounds ", IDorigin, " and ", IDtarget),  
       ylab = "Elevation(m)", xlab = "Mound distance in pixels (*30m)"); 
  lines(x,y, col = "red", lwd = 2)
  
}

origin <- 9412
target <- 9414
profile(9412, 8242) # these two points are at opposite sides of the region

# Plot
plot(testprofile$z, type = "b"); 

```

## Prominence point map
We have mound-centereed indeces of ruggedness and topographic prominence, which should align with the objective/dry measure of visibility above.
The measures are at different scales. Prominence in 250m buffer specifies how big a fraction (in percentages) of the surrounding area is visible to a person on the mound.
TPI is measured from on a scale from -3 to 2 , with most values between 0 and 1. TRI is between 0 and 4, with median at 1. Rough measure goes from 0 to 15, with mean at 3.7.
```{r}
# various measures of prominence
summary(Yam_mnds[, c("prom250mbuff", "TPI", "TRI", "rough")])


# prominence in 250m buffer
Yam_mnds %>% 
  filter(prom250mbuff > 85) %>% 
  mapview(zcol = "prom250mbuff") # 9412 not present!

# TPI
hist(Yam_mnds$TPI)
Yam_mnds %>% 
  filter(TPI >= 1) %>% 
  mapview(zcol = "TPI")# 9412 not present!

# TRI
hist(Yam_mnds$TRI)
Yam_mnds %>% 
  filter(TRI >= 2.53) %>% 
  mapview(zcol = "TRI")# 9412 not present!

# rough
hist(Yam_mnds$rough)
Yam_mnds %>% 
  filter(rough >= 7) %>% 
  mapview(zcol = "rough")# 9412 not present!
```


### BA mound subgroup
to keep things simple
```{r BA-faims, include = FALSE}
# Filter out the BA mounds from the FAIMS data
bronze <- c(6009,8007,6010,8345,8346,8357, 8502, 8351, 9257)
BA <- Yam_mnds %>% 
  filter(TRAP %in% bronze)

# Add literature dimensions to mound 8345, which was excavated before survey 
BA$DiameterMax[5] <- 37.5
BA$HeightMax[5] <- 3.2

```


```{r BA-cansee}
mapview(BA[c(3,6,5),])
m8007 <- c(st_coordinates(BA)[3,],h= BA$HeightMax[3])
m8346 <- c(st_coordinates(BA)[6,],h= BA$HeightMax[6])
m8502<- c(st_coordinates(BA)[7,],h= BA$HeightMax[7])
m8345 <- c(st_coordinates(BA)[5,],h= BA$HeightMax[5])
Y_elev

test_see <- cansee(Y_elev, m8345, m8346, h1 = m8345[3]  , h2 = m8346[3])
test_see

```
## Linestring creation

Let's first see if we an create linestrings to later signal which mounds can *see* each other. To do that we need two columns of coordinates: the origin and the target. Here we explore the intervisibility of the seven BA mounds
```{r linestring}
# Test linestring creation from one origin and multiple target points. The coords object needs to be a matrix, but to cbind one to many coordinates the component columns need to be dataframes.

coords <- as.matrix(cbind(as.data.frame(st_coordinates(BA[2])),
                as.data.frame(st_coordinates(BA))))

lines_sm <-  st_sfc(
     lapply(1:nrow(coords),
           function(i){
             st_linestring(matrix(coords[i,],ncol=2,byrow=TRUE))
           }))

st_crs(lines_sm) <- st_crs(BA)


library(mapview)
mapview(lines_sm)+mapview(BA)

# https://stackoverflow.com/questions/65498300/how-to-efficiently-create-linestrings-from-points
# https://stackoverflow.com/questions/58150279/plotting-lines-between-two-sf-point-features-in-r
```

### Visualizing the terrain profile
```{r raster-profile}
# Create a terrain profile and plot it to check potential intervisibility
testprofile <- rasterprofile(Y_elev,  m8007, m8346)
testprofile <- rasterprofile(Y_elev,  m8007, m8345)
testprofile <- rasterprofile(Y_elev,  st_coordinates(Yam_mnds[1,]), st_coordinates(Yam_mnds[333,]))

# Plot
plot(testprofile$z, type = "b"); 

# create the connecting line between origin and destination points
x = c(0,nrow(testprofile))
y = testprofile$z[c(1,nrow(testprofile))]

# Plot profile with start and end point elevation
plot(testprofile$z, type = "l", main = "Terrain profile between mounds 8345 and 8346", 
     ylab = "Elevation(m)", xlab = "Mound distance (*30m)"); 
lines(x,y, col = "red", lwd = 2)

```

SOme of the mounds (Drazhevo and 8346) can not see each other, because the one on top of the Zaichi Vrah is obscured by the hill and not aimed at the mounds to the SE.  Others with clear line of sight can see one another.
Let's test the intervisibility between these three and other mounds in the surroundings from the Yambol Mounds dataset. We will use the viewTo() function and the starting coordinates of the three mounds.

```{r view-to-8007, warning=FALSE}
# First we need to convert the Yambol mounds to a matrix of coordinates
coords <- data.frame(st_coordinates(Yam_mnds),h=Yam_mnds$HeightMax)
missingHeight <- which(is.na(coords$h))
mnd_missH <- Yam_mnds$TRAP[missingHeight]

coords <- coords %>% 
  filter(!is.na(h))
coords_m <- as.matrix(coords)

# viewTo() working with 3 points
testview <- viewTo(Y_elev, m8007, rbind(m8346,m8345))

# with all points (uncomment if you wish to regenerate!)
# testview <- viewTo(Y_elev, m8007, coords_m,m8007[3], coords_m[,3])
# length(testview)


# # See which ones can see 8007
# '%nin%' = Negate('%in%')
# viewTo_8007 <- Yam_mnds %>% 
#   filter(TRAP %nin% mnd_missH) %>%   # must first filter away missing heights as I did with coordinates
#   filter(testview) # use the logical vector to filter the Yam_mnds rows

# 289 mounds can see mound 8007
# saveRDS(viewTo_8007, "../output_data/MoundsVisfrom8007.rds")
viewTo_8007 <- readRDS("../output_data/MoundsVisfrom8007.rds")
```

View these 289 mounds visible from 8007
```{r plot-visible}
# Test linestring creation from one origin and multiple target points. The coords object needs to be a matrix, but to cbind one to many coordinates the component columns need to be dataframes.
coords <- as.matrix(cbind(rep(m8007[1], 289),rep(m8007[2], 289), st_coordinates(viewTo_8007)))

lines <-  st_sfc(
     lapply(1:nrow(coords),
           function(i){
             st_linestring(matrix(coords[i,],ncol=2,byrow=TRUE))
           }))

st_crs(lines) <- st_crs(BA)

library(mapview)
library(leafsync)
m1 <- mapview(lines) + mapview(viewTo_8007, cex = 4) + mapview(BA[3,], cex = 10)
m2 <- mapview(viewTo_8007, zcol = "prom250mbuff")
sync(m1,m2)
```




## Intervisibility of Bronze Age mounds in Yambol (not sure if needed)
In this proof of concept we explore the visibility of BA mounds from other BA mounds, for simplicity's sake. 

BA mounds comprise surveyed and excavated mounds ('bronze') and excavated prior to survey ('extrasf') supplied by Toshko.

Excavated prior:
Drazhevo - Height: 2.7 m; Diameter: 37.0 m; Land: pasture on the rocky area
Straldzha - Height: 4.0 m; Diameter: 50.0 m; Land: wines and pasture
Popovo - Height: 6.8 m; Diameter: 48.0 m; Land: wines and pasture

8345 Mogila village - Height: 3.2 m; Diameter: 37.6 m; Land: pasture on the rocky area 


```{r BA-faims, include = FALSE}
# Filter out the BA mounds from the FAIMS data
bronze <- c(6009,8007,6010,8345,8346,8357, 8502, 8351, 9257)
BA <- Yam_mnds %>% 
  filter(TRAP %in% bronze)

# Add literature dimensions to mound 8345, which was excavated before survey 
BA$DiameterMax[5] <- 37.5
BA$HeightMax[5] <- 3.2

```

```{r BA-Todor, include = FALSE}
# Add the few mounds excavated before TRAP coverage >> these should be pulled out of the AOR dataset to get the Height, Diameter and other dimensions..
extras <- data.frame(place = c("Drazhevo", 
                           "Straldzha",
                           "Popovo"),
                 Easting=c(455442,479522,479391),
                 Northing=c(4710935,4715730,4668279),
                 HeightMax=c(2.7,4.0,6.8),
                 DiameterMax = c(37,50,48),
                 LU_Around = c("Pasture","Perennial","Perennial"),
                 Type = c("Burial Mound","Burial Mound","Burial Mound"),
                 Source = c("Excavation","Excavation","Excavation"))
extrasf <- st_as_sf(extras, coords =c("Easting", "Northing"), crs = 32635)

```

```{r BA-combo, include = FALSE}
# Combine both BA datasets and spatialize
library(plyr)
BApoints <- rbind.fill(BA, extrasf)
BAcoords <- rbind(st_coordinates(BA) ,st_coordinates(extrasf))
BApoints <- cbind(BApoints, BAcoords)
BApoints <- st_as_sf(BApoints, coords = c("X", "Y"), crs = 32635)
```
