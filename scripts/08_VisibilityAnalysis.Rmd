---
title: "Visibility"
author: "Adela Sobotkova"
date: "2022-12-14"
output: html_document
---
## Purpose and prerequisites:
This script serves to elaborate the calculation of mutual intervisibility (clear line of sight) between various archaeological features, starting here with burial mounds in the Yambol Region and ASTER elevation raster (30m spatial resolution). 

The script basically works, calculating linestrings, intervisibility between Yam_mounds and generating maps

The proof of concept is done on BA mounds and to replicate it you might need: 
- to run 09 BA mounds to have the necessary libraries and digital objects

THe code should be expandable
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE)
library(sf)
library(raster)
library(tidyverse)
```

## Load 2009-2022 data
```{r load-mounds}

Y_elev <- raster("../output_data/large/Yelev32635.tif")
# Yambol mounds
Yam_mnds <- readRDS("../output_data/Yam_dd_mnds.rds") # 1073 features
Yam_mnds
Yam_mnds %>% 
  group_by(Type) %>% 
  tally()
```

## BA mound subgroup
to keep things simple
```{r BA-faims, include = FALSE}
# Filter out the BA mounds from the FAIMS data
bronze <- c(6009,8007,6010,8345,8346,8357, 8502, 8351, 9257)
BA <- Yam_mnds %>% 
  filter(TRAP %in% bronze)

# Add literature dimensions to mound 8345, which was excavated before survey 
BA$DiameterMax[5] <- 37.5
BA$HeightMax[5] <- 3.2

```


## Linestring creation

Let's first see if we an create linestrings to later signal which mounds can *see* each other. To do that we need two columns of coordinates: the origin and the target. Here we explore the intervisibility of the seven BA mounds
```{r linestring}
# Test linestring creation from one origin and multiple target points. The coords object needs to be a matrix, but to cbind one to many coordinates the component columns need to be dataframes.

coords <- as.matrix(cbind(as.data.frame(st_coordinates(BA$geometry[2])),
                as.data.frame(st_coordinates(BA$geometry))))

lines_sm <-  st_sfc(
     lapply(1:nrow(coords),
           function(i){
             st_linestring(matrix(coords[i,],ncol=2,byrow=TRUE))
           }))

st_crs(lines_sm) <- st_crs(BA)


library(mapview)
mapview(lines_sm)+mapview(BA)

# https://stackoverflow.com/questions/65498300/how-to-efficiently-create-linestrings-from-points
# https://stackoverflow.com/questions/58150279/plotting-lines-between-two-sf-point-features-in-r
```
 
## Intervisibility

Intervisibility in human terms mean that two or more points in the landscape have a clear line of sight between them (given reasonable visibility). In computational terms, it means that a straight line connecting the z values of the A and B (the two end-points) does not intersect a polygon formed by terrain profile between them. If it doesn't, A can see B.
Let's test such line of sight by extracting data out of raster cells between our BA points.

https://stackoverflow.com/questions/21841387/r-code-that-evaluates-line-of-sight-los-between-two-lat-lon-points 

https://gis.stackexchange.com/questions/272122/performing-viewshed-analysis-in-r
```{r define-cansee-functions}
cansee <- function(r, xy1, xy2, h1=0, h2=0){
### can xy1 see xy2 on DEM r?
### Y_elev is a DEM in same x,y, z units
### xy1 and xy2 are 2-length vectors of x,y coords
### h1 and h2 are extra height offsets (ie. mound heights)
###  (eg top of mast, observer on a ladder etc)
    xyz = rasterprofile(r, xy1, xy2)
    np = nrow(xyz)-1
    h1 = xyz$z[1] + h1
    h2 = xyz$z[np] + h2
    hpath = h1 + (0:np)*(h2-h1)/np
    return(!any(hpath < xyz$z))
}

viewTo <- function(r, xy, xy2, h1=0, h2=0, progress="none"){
    ## xy2 is a matrix of x,y coords (not a data frame)
    require(dplyr)
    apply(xy2, 1, function(d){cansee(r,xy,d,h1,h2)}, .progress=progress)
}

viewTo <- function(r, xy, xy2, h1=0, h2=0){
    ## xy2 is a matrix of x,y coords (not a data frame)
    require(dplyr)
    apply(xy2, 1, function(d){cansee(r,xy,d,h1,h2)})
}

rasterprofile <- function(r, xy1, xy2){
### sample a raster along a straight line between two points
### try to match the sampling size to the raster resolution
    dx = sqrt( (xy1[1]-xy2[1])^2 + (xy1[2]-xy2[2])^2 )
    nsteps = 1 + round(dx/ min(res(r)))
    xc = xy1[1] + (0:nsteps) * (xy2[1]-xy1[1])/nsteps
    yc = xy1[2] + (0:nsteps) * (xy2[2]-xy1[2])/nsteps
    data.frame(x=xc, y=yc, z=r[cellFromXY(r,cbind(xc,yc))])
}
```
Let's test these three functions with real data (BA points)


```{r rasterprofile}
mapview(BA[c(3,6,5),])
m8007 <- c(st_coordinates(BA)[3,],h= BA$HeightMax[3])
m8346 <- c(st_coordinates(BA)[6,],h= BA$HeightMax[6])
m8502<- c(st_coordinates(BA)[7,],h= BA$HeightMax[7])
m8345 <- c(st_coordinates(BA)[5,],h= BA$HeightMax[5])
Y_elev

test_see <- cansee(Y_elev, m8345, m8346, h1 = m8345[3]  , h2 = m8346[3])
test_see

```

## Automating the visibility calculation

### prep the data for cansee() function
```{r auto-prep}
# origin point coordinates and height
Yam_mnds %>% 
  group_by(Type) %>% tally()

Yam_mnds$HeightMax[is.na(Yam_mnds$HeightMax)] <- 0


origin <- cbind(st_coordinates(Yam_mnds), h = Yam_mnds$HeightMax)
target <- origin 

class(origin)
```

### slow automation via a for-loop
```{r loop}
# LOOP: works but takes days to finish, reduce the i and e if running a test!
result_table <- NULL
for (i in 1:nrow(origin)){
  for (e in 1:nrow(target)){print(e)
      result = cansee(Y_elev, origin[i,1:2], target[e,1:2], h1 = origin[i,3], h2 = target[e,3])
    result_row <- cbind(i,e, result) 
    result_table <- rbind(result_table, result_row)
  }

}

# I stopped the process after 24 hours when it reached ~250,000 calculations
# maxima were i = 241, and e = 780 ; restart the calculations there

head(result_table)
tail(result_table)
saveRDS(result_table, "../output_data/Yam_mnd_intervis250k.rds")

```

Finishing the 1,000,000 calculations takes a while! (1 hr so far at 17.18 on Thursday night).
OK, some 24 hours later (Friday afternoon), 241 mounds (*1000) were completed. Clearly the tasks takes 4 days unless we successfully ...

### Parallelize!
```{r auto-foreach}
# install.packages("doParallel")
# install.packages("foreach")
library(foreach)
library(doParallel)
library(data.table)

detectCores() # 22 as some are multi-threaded
detectCores(logical = FALSE) # 16 real ones

cl <- makeCluster(12) # keep 4 cores so screensaver can run on W11
registerDoParallel(cl)

# Start experiment
origin <- cbind(st_coordinates(Yam_mnds), h = Yam_mnds$HeightMax)
target <- origin 

# nesting both i and e with foreach 
ie_table <- foreach (i= 1:nrow(origin), .combine = 'rbind',.packages = c("data.table", "raster")) %do% {
  print(i)
  foreach( e= 1:nrow(target), .combine = 'rbind',.packages = c("data.table", "raster")) %dopar% {
  print(e)
  result = cansee(Y_elev, origin[i,1:2], target[e,1:2], h1 = origin[i,3], h2 = target[e,3])
  result_row <- c(i,e, result)
  }
 # result_table <- rbind(result_table, result_row)
}

dim(ie_table) # 1,151,329 calculations take ~12 hours (10x less than for loop) 
saveRDS(ie_table, "../output_data/Yam_mnds_intervis.rds")
```
### Compare efficiency between for-loop and foreach
Let's run 4 * 4 (16) or/and 14*14 (~196) calculations using both a for loop and foreach to compare their relative speeds.

```{r compare-loop-foreach}
loop_table <- NULL
runtime1 <- system.time(
for (i in 1060:nrow(origin)){
  print(i)
  for (e in 1060:nrow(target)) {
    print(e)
    result = cansee(Y_elev, origin[i,1:2], target[e,1:2], h1 = origin[i,3], h2 = target[e,3])
    result_row <- cbind(i,e, result)
   loop_table <- rbind(loop_table, result_row)
    }
}
)

runtime2 <- system.time(
parallel_table <- foreach (i= 1060:nrow(origin), .combine = 'rbind',.packages = c("data.table", "raster")) %do% {
  print(i)
  foreach( e= 1060:nrow(target), .combine = 'rbind',.packages = c("data.table", "raster")) %dopar% {
  print(e)
  result = cansee(Y_elev, origin[i,1:2], target[e,1:2], h1 = origin[i,3], h2 = target[e,3])
  result_row <- c(i,e, result)
  }
}
)

dim(parallel_table)
dim(loop_table)
runtime1
runtime2
```

At 16 iterations (16 results), the foreach 'elapsed' time is half of the loop and 'user' time is 5x less.
> runtime1
   user  system elapsed 
   0.06    0.01    0.23 
> runtime2
   user  system elapsed 
   0.01    0.00    0.13 
   
At 196 iterations (196 results), the foreach (with 12 cores) 'elapsed' time is 1/3 of the for loop and 'user' time is 50x less    
> runtime1
   user  system elapsed 
   0.53    0.02    3.14 
> runtime2
   user  system elapsed 
   0.01    0.00    1.06
   
### explore intervisibility results   
```{r results-test}
# Check the results of the initial intervisibility run
result_table <- readRDS("../output_data/Yam_mnds_intervis.rds")
result_table <- as.tibble(result_table)

head(result_table)
result_table <- result_table %>% 
  rename(i = V1, e = V2, visibility = V3)

# 10 most commanding mounds! i is the index, n is the number of visible features from it
result_table %>% 
  group_by(i) %>% 
  tally(visibility) %>% 
  arrange(desc(n)) # mounds no 333, 38 and 1 see the most other mounds (393-409)

# all the mounds visible from mound no. 333 (n = 409)
result_table %>% 
  filter(i == 333, visibility == 1) %>% 
  arrange(desc(e)) %>% 
  distinct(TRAPtarget) %>% 
  pull() -> visiblefrom9412

```



### Link results to actual mound locations

```{r link-TRAP-to-results}
result_table$TRAPorigin <- Yam_mnds$TRAP[result_table$i]
result_table$TRAPtarget <- Yam_mnds$TRAP[result_table$e]

```


```{r most-intervisible-map}

library(mapview)

result_table %>% 
  group_by(TRAPorigin) %>% 
  tally(visibility) %>% 
  arrange(desc(n)) %>% 
  slice(1:25) %>% 
  #rename(TRAP = TRAPorigin) %>% 
  #merge(Yam_mnds, by = c("TRAP")) #%>% 
  left_join(Yam_mnds, by = c("TRAPorigin"="TRAP")) %>%
  st_as_sf(crs = 32635) %>% 
  mapview(cex = "n" , zcol = "HeightMax") +mapview(Yam_mnds,cex = 0.1) +
  mapview(Yam_mnds %>% dplyr::filter(TRAP%in%visiblefrom9412), cex = 1)

```


### Visualizing the terrain profile
```{r}
# Create a terrain profile and plot it to check potential intervisibility
testprofile <- rasterprofile(Y_elev,  m8007, m8346)
testprofile <- rasterprofile(Y_elev,  m8007, mDrazh)
testprofile <- rasterprofile(Y_elev,  mDrazh, m8346)

# Plot
plot(testprofile$z, type = "b"); 

# create the connecting line between origin and destination points
x = c(0,nrow(testprofile))
y = testprofile$z[c(1,nrow(testprofile))]

# Plot profile with start and end point elevation
plot(testprofile$z, type = "l", main = "Terrain profile between mounds 8346 and Drazhevo", 
     ylab = "Elevation(m)", xlab = "Mound distance (*30m)"); 
lines(x,y, col = "red", lwd = 2)

```

None of these mounds (Drazhevo and 8346) can see each other, because the one on top of the Zaichi Vrah is obscured by the hill and not aimed at the mounds to the SE. 
Let's test the intervisibility between these three and other mounds in the surroundings from the Yambol Mounds dataset. We will use the viewTo() function and the starting coordinates of the three mounds.

```{r view-to-8007, warning=FALSE}
# First we need to convert the Yambol mounds to a matrix of coordinates
coords <- data.frame(st_coordinates(Yam_mnds),h=Yam_mnds$HeightMax)
missingHeight <- which(is.na(coords$h))
mnd_missH <- Yam_mnds$TRAP[missingHeight]

coords <- coords %>% 
  filter(!is.na(h))
coords_m <- as.matrix(coords)

# viewTo() working with 3 points
testview <- viewTo(Y_elev, m8007, rbind(m8346,mDrazh))

# with all points (uncomment if you wish to regenerate!)
# testview <- viewTo(Y_elev, m8007, coords_m,m8007[3], coords_m[,3])
# length(testview)


# # See which ones can see 8007
# '%nin%' = Negate('%in%')
# viewTo_8007 <- Yam_mnds %>% 
#   filter(TRAP %nin% mnd_missH) %>%   # must first filter away missing heights as I did with coordinates
#   filter(testview) # use the logical vector to filter the Yam_mnds rows

# 289 mounds can see mound 8007
# saveRDS(viewTo_8007, "../output_data/MoundsVisfrom8007.rds")
viewTo_8007 <- readRDS("../output_data/MoundsVisfrom8007.rds")
```

View these 289 mounds visible from 8007
```{r plot-visible}
# Test linestring creation from one origin and multiple target points. The coords object needs to be a matrix, but to cbind one to many coordinates the component columns need to be dataframes.
coords <- as.matrix(cbind(rep(m8007[1], 289),rep(m8007[2], 289), st_coordinates(viewTo_8007)))

lines <-  st_sfc(
     lapply(1:nrow(coords),
           function(i){
             st_linestring(matrix(coords[i,],ncol=2,byrow=TRUE))
           }))

st_crs(lines) <- st_crs(BA)

library(mapview)
library(leafsync)
m1 <- mapview(lines) + mapview(viewTo_8007, cex = 4) + mapview(BA[3,], cex = 10)
m2 <- mapview(viewTo_8007, zcol = "prom250mbuff")
sync(m1,m2)
```




## Intervisibility of Bronze Age mounds in Yambol (not sure if needed)
In this proof of concept we explore the visibility of BA mounds from other BA mounds, for simplicity's sake. 

BA mounds comprise surveyed and excavated mounds ('bronze') and excavated prior to survey ('extrasf') supplied by Toshko.

Excavated prior:
Drazhevo - Height: 2.7 m; Diameter: 37.0 m; Land: pasture on the rocky area
Straldzha - Height: 4.0 m; Diameter: 50.0 m; Land: wines and pasture
Popovo - Height: 6.8 m; Diameter: 48.0 m; Land: wines and pasture

8345 Mogila village - Height: 3.2 m; Diameter: 37.6 m; Land: pasture on the rocky area 


```{r BA-faims, include = FALSE}
# Filter out the BA mounds from the FAIMS data
bronze <- c(6009,8007,6010,8345,8346,8357, 8502, 8351, 9257)
BA <- Yam_mnds %>% 
  filter(TRAP %in% bronze)

# Add literature dimensions to mound 8345, which was excavated before survey 
BA$DiameterMax[5] <- 37.5
BA$HeightMax[5] <- 3.2

```

```{r BA-Todor, include = FALSE}
# Add the few mounds excavated before TRAP coverage >> these should be pulled out of the AOR dataset to get the Height, Diameter and other dimensions..
extras <- data.frame(place = c("Drazhevo", 
                           "Straldzha",
                           "Popovo"),
                 Easting=c(455442,479522,479391),
                 Northing=c(4710935,4715730,4668279),
                 HeightMax=c(2.7,4.0,6.8),
                 DiameterMax = c(37,50,48),
                 LU_Around = c("Pasture","Perennial","Perennial"),
                 Type = c("Burial Mound","Burial Mound","Burial Mound"),
                 Source = c("Excavation","Excavation","Excavation"))
extrasf <- st_as_sf(extras, coords =c("Easting", "Northing"), crs = 32635)

```

```{r BA-combo, include = FALSE}
# Combine both BA datasets and spatialize
library(plyr)
BApoints <- rbind.fill(BA, extrasf)
BAcoords <- rbind(st_coordinates(BA) ,st_coordinates(extrasf))
BApoints <- cbind(BApoints, BAcoords)
BApoints <- st_as_sf(BApoints, coords = c("X", "Y"), crs = 32635)
```
