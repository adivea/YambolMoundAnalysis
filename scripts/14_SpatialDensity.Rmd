---
title: "Density of Mounds"
author: "Adela Sobotkova"
date: "25 January 2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Libraries
```{r}
library(tidyverse)
library(sf)
library(raster)
```

# Load Vector data
```{r load-Y-vector}
# Load vectors
bg_border <- st_read("../../YambolMoundAnalysis/data/Bulgaria_Border.shp")
Y_towns <- st_read("../../YambolMoundAnalysis/data/Modern_settlements_Yambol_TRAP.shp")
#towns <- st_read("~/../Documents/Professional/Projects/MQNS/GIS/Vectors/Yamurbanarea.shp") # towns within 15km buffer of Yambol boundary exported from JICA
Y_region <- st_read("../../YambolMoundAnalysis/data/YamRegion.shp")
Y_towns_poly <- read_sf("../../YambolMoundAnalysis/data/YamTownpoly/Yam_towns_poly.shp")
```

# Load Map Digitisation results
```{r}
map_mnd <- st_read("../../MapMoundsDigitised/output_data/MapMounds4326.shp")
map_mnd <- read_csv("../../MapMoundsDigitised/output_data/MapMounds17_18LLgood.csv")
map_mnd <- map_mnd %>% 
  filter(!is.na(Latitude)) %>% 
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326) %>% 
  st_transform(crs = 32635)
```

```{r rayed}
# Variants of rayed symbols
unique(map_mnd$MapSymbol[grep("Hairy*",x = map_mnd$MapSymbol)])

# Pull a rayed subset
rayed <- map_mnd %>% 
  filter(grepl("Hairy*",MapSymbol))

```

# Intersect
# Visual review
```{r}
plot(Y_region$geometry,  col = "pink")
plot(st_intersection(rayed$geometry, Y_region), add = TRUE)

Y_digit <- st_intersection(map_mnd,Y_region)

```

# Subset only mounds 'Hairy triangles' and other rayed symbols.

```{r}
plot(Y_region$geometry,  col = "pink")
plot(Y_digit %>% 
       filter(grepl("Hairy*", MapSymbol))%>%
       select(geometry), add = TRUE)

Y_digmnd <- Y_digit %>% filter(grepl("Hairy brown*", MapSymbol))

plot(Y_region$geometry,  col = "pink")
plot(Y_digmnd$geometry, cex = 0.5, add = TRUE )
```

       

# Create a density following https://rspatial.org/raster/analysis/8-pointpat.html
# mean center of the projected coordinates

```{r}
xy <- st_coordinates(Y_digmnd)
dim(xy)
mc <- apply(xy, 2, mean)
# standard distance
sd <- sqrt(sum((xy[,1] - mc[1])^2 + (xy[,2] - mc[2])^2) / nrow(xy))

```

# Display the center of all mounds
```{r}
plot(Y_region$geometry,  col = "pink")
plot(Y_digmnd$geometry, cex = 0.5, add = TRUE )
points(cbind(mc[1], mc[2]), pch='*', col='red', cex=5)

# make a circle
bearing <- 1:360 * pi/180
cx <- mc[1] + sd * cos(bearing)
cy <- mc[2] + sd * sin(bearing)
circle <- cbind(cx, cy)
lines(circle, col='red', lwd=2)
```

# Density
# Basic approach to computing point density

```{r}
library(units)

Y_area <- st_area(Y_region)
set_units(Y_area, km^2)

dens <- nrow(Y_digmnd)/Y_area
set_units(dens, km^2)
```

To compute quadrat counts I first create quadrats (a RasterLayer). I get the extent for the raster from the city polygon, and then assign an an arbitrary resolution of 1000. (In real life one should always try a range of resolutions, I think).

```{r}
r <- raster(Y_region)
res(r) <- 5000 # basically 5000 m
r
```
To find the cells that are in the city, and for easy display, I create polygons from the RasterLayer.

```{r}
r <- rasterize(Y_region, r)
plot(r)
quads <- as(r, 'SpatialPolygons')
plot(quads, add=TRUE)
plot(Y_digmnd$geometry, col='red', cex=.5, add=TRUE)

```

The number of events in each quadrat can be counted using the ‘rasterize’ function. That function can be used to summarize the number of points within each cell, but also to compute statistics based on the ‘marks’ (attributes). For example we could compute the number of different crime types) by changing the ‘fun’ argument to another function (see ?rasterize).

```{r}
ym <- rasterize(st_coordinates(Y_digmnd), r, fun='count', background=0)
plot(ym)
plot(Y_region$geometry, add=TRUE)
```

ym has mound counts. As we only have data for the yambol region, the areas outside of the region need to be excluded. We can do that with the mask function (see ?mask)

```{r}
ymnds <- mask(ym, r)
plot(ymnds)
plot(Y_region$geometry, add=TRUE)

```

Better. Now the frequencies.

```{r}
f <- freq(ymnds, useNA='no')
head(f)
plot(f, pch=20)
```

Does this look like a pattern you would have expected? Now compute average number of cases per quadrat.



## Exercise 2: Spatstat package
Above we did some ‘home-brew’ point pattern analysis, we will now use the spatstat package. In research you would normally use spatstat rather than your own functions, at least for standard analysis. I showed how you make some of these functions in the previous sections, because understanding how to go about that may allow you to take things in directions that others have not gone. The good thing about spatstat is that it very well documented (see http://spatstat.github.io/). The bad thing is that it uses an entirly different sets of classes (ways to represent spatial data) that we we will use in all other labs (classes from sp and raster); but it is not hard to get used to that.

```{r}
library(spatstat)
```

We start with making make a Kernel Density raster. I first create a ‘ppp’ (point pattern) object, as defined in the spatstat package.

A ppp object has the coordinates of the points and the analysis ‘window’ (study region). To assign the points locations we need to extract the coordinates from our SpatialPoints object. To set the window, we first need to to coerce our SpatialPolygons into an ‘owin’ object. We need a function from the maptools package for this coercion.

Coerce from SpatialPolygons to an object of class “owin” (observation window)

```{r}
library(maptools)
regOwin <- as.owin(Y_region$geometry)
class(regOwin)
## [1] "owin"
regOwin
## window: polygonal boundary
## enclosing rectangle: [6620591, 6654380] x [1956729.8, 1971518.9] units
```

Extract coordinates from SpatialPointsDataFrame:

```{r}
pts <- st_coordinates(Y_digmnd)
head(pts)
##      coords.x1 coords.x2
## [1,]   6628868   1963718
## [2,]   6632796   1964362
## [3,]   6636855   1964873
## [4,]   6626493   1964343
## [5,]   6639506   1966094
## [6,]   6640478   1961983
```

Now we can create a ‘ppp’ (point pattern) object

```{r}
p <- ppp(pts[,1], pts[,2], window=regOwin)
## Warning: 20 points were rejected as lying outside the specified window
## Warning: data contain duplicated points
class(p)
p
plot(p)
```

Having all the data well organized, it is now easy to compute Kernel Density

```{r}
ds <- density(p)
class(ds)
## [1] "im"
plot(ds, main='mound symbol density')
```
Density is the number of points per unit area. Let’s check if the numbers makes sense, by adding them up and mulitplying with the area of the raster cells. I use raster package functions for that.

```{r}
nrow(pts)
## [1] 965
r <- raster(ds)
s <- sum(values(r), na.rm=TRUE)
s * prod(res(r))
## [1] 966.3472
```
Looks about right. We can also get the information directly from the “im” (image) object

```{r}
str(ds)
sum(ds$v, na.rm=TRUE) * ds$xstep * ds$ystep
## [1] 966.3472
p$n
## [1] 965
```
Create a marked point pattern object (ppp) for all mound symbols. It is important to coerce the marks to a factor variable.

```{r}
Y_digmnd$MapSymbol <- as.factor(Y_digmnd$MapSymbol)
mpp <- ppp(xy[,1], xy[,2], window = regOwin, marks=Y_digmnd$MapSymbol)
```

We can split the mpp object by category
```{r}
spp <- split(mpp)
plot(spp[1:4], main='')
```
The mound symbol density by category:
```{r}
plot(density(spp[1:4]), main='')
```
And produce K-plots (with an envelope) for ‘Hairy black triangle with a dot inside’ and ‘Hairy brown circle’. Can you explain what they mean?

```{r Kest}
# The Ripley's K-function can take couple hours to calculate (3:20:13 on sunbursts, specifically) so feel free to load the datasets from the data folder
spatstat.options(checksegments = FALSE)
ktriangle <- Kest(spp$"Hairy black triangle with a dot inside")
#ketriangle <- envelope(spp$"Hairy black triangle with a dot inside", Kest)  # you can instead load the ketriangle.rds

spatstat.options(checksegments = FALSE)
ksun <- Kest(spp$"Hairy brown circle")
#kesun <- envelope(spp$"Hairy brown circle", Kest) # you can instead load the kesun.rds

```

```{r data-saved, eval=FALSE}
write_rds(ketriangle, path="../output_data/ketriangle.rds", compress = "none")
write_rds(kesun,path= "../output_data/kesun.rds", compress = "none" )
```

```{r plot-subursts}
par(mfrow=c(1,2))
plot(ksun)
plot(kesun)
```

```{r plot-triangle}
par(mfrow=c(1,2))
plot(ktriangle)
plot(ketriangle)
```
Let’s try to answer the question you have been wanting to answer all along. Is population density a good predictor of being (booked for) “drunk in public” and for “Arson”? One approach is to do a Kolmogorov-Smirnov (‘kstest’) on ‘Drunk in Public’ and ‘Arson’, using population density as a covariate:
